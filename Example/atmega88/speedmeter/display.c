/* Графический модуль для работы с графическими индикаторами на драйвере
UC1601S,для индикатора RDX0154-GC
AVR Studio 6
*Created: 24.06.2013 14:24:23
*/
#include "display.h"

/*
   Дисплей RDX0154-GC

		   Cтолбцы                   Верх
					  0___________________________131
   0 страница памяти |байт |
   1 страница памяти | |
   2 страница памяти | |   Лево
   3 страница памяти | |
   4 страница памяти | |
   5 страница памяти | |
   6 страница памяти | |
   7 страница памяти | |             Низ
					 -------------------------------
*/

//Знакогенераторы
//Большие цифры

// 12 символов размером 32х32, 4 страницы  памяти по 32 байта,32*4=128 ячеек для одного символа
const  unsigned char znakogen[12][128] PROGMEM = {
// символ 0
{
 0,0,0,0,0,0,0,192,
240,248,252,60,28,30,30,30,
30,28,60,252,248,240,192,0,
0,0,0,0,0,0,0,0,


0,0,0,0,0,0,254,255,
255,255,0,0,0,0,0,0,
0,0,0,0,255,255,255,254,
0,0,0,0,0,0,0,0,


0,0,0,0,0,0,255,255,
255,255,0,0,0,0,0,0,
0,0,0,0,255,255,255,255,
0,0,0,0,0,0,0,0,


0,0,0,0,0,0,1,7,
31,63,124,120,240,224,224,224,
224,240,120,124,63,31,15,1,
0,0,0,0,0,0,0,0
},
{   // 1
	0,0,0,0,0,0,0,0,
	192,192,192,192,224,224,248,252,
	252,252,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,


	0,0,0,0,0,0,0,0,
	0,1,1,1,1,1,255,255,
	255,255,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,


	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,255,255,
	255,255,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	96,240,240,240,240,240,255,255,
	255,255,240,240,240,240,96,0,
	0,0,0,0,0,0,0,0

},
{ //2
	0,0,0,0,0,0,0,120,
	60,60,28,28,30,30,30,30,
	30,60,124,248,248,240,128,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,128,224,255,255,127,31,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	0,0,128,192,224,240,120,60,
	31,15,7,3,1,0,0,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,120,252,
	254,255,247,243,241,240,240,240,
	240,240,240,240,240,240,240,240,
	0,0,0,0,0,0,0,0
},
{  //3
	0,0,0,0,0,0,0,120,
	60,60,28,28,30,30,30,30,
	30,28,60,252,248,240,224,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	0,0,0,0,192,192,192,192,
	224,224,112,63,63,31,7,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	0,0,0,0,1,1,1,1,
	1,3,3,15,255,254,252,224,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,124,120,
	120,240,240,240,224,224,224,240,
	240,240,120,126,63,31,7,1,
	0,0,0,0,0,0,0,0
},
//4
{
	0,0,0,0,0,0,0,0,
	0,0,0,0,0,128,192,224,
	240,120,252,252,252,252,0,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,0,128,192,
	224,240,120,62,31,7,3,1,
	0,0,255,255,255,255,0,0,
	0,0,0,0,0,0,0,0,

	0,0,0,0,0,31,31,31,
	29,28,28,28,28,28,28,28,
	28,28,255,255,255,255,28,28,
	28,0,0,0,0,0,0,0,

	0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,
	0,0,255,255,255,127,0,0,
	0,0,0,0,0,0,0,0
},
//5
	   {
		   0,0,0,0,0,0,0,0,
		   252,252,252,28,28,28,28,28,
		   28,28,28,28,28,28,28,28,
		   0,0,0,0,0,0,0,0,

		   0,0,0,0,0,0,0,0,
		   255,255,255,224,224,224,224,224,
		   224,224,192,192,128,0,0,0,
		   0,0,0,0,0,0,0,0,

		   0,0,0,0,0,0,0,0,
		   1,1,1,0,0,0,0,0,
		   1,1,3,7,255,255,254,248,
		   0,0,0,0,0,0,0,0,

		   0,0,0,0,0,0,56,120,
		   120,240,240,240,224,224,224,224,
		   240,240,120,126,63,31,15,1,
		   0,0,0,0,0,0,0,0
	   },
	//6
				{
					0,0,0,0,0,0,0,0,
					128,224,240,240,120,60,60,28,
					30,30,30,30,30,28,0,0,
					0,0,0,0,0,0,0,0,

					0,0,0,0,0,0,240,254,
					255,255,195,192,224,224,224,240,
					240,224,224,224,192,192,128,0,
					0,0,0,0,0,0,0,0,

					0,0,0,0,0,0,255,255,
					255,255,1,0,0,0,0,0,
					0,0,1,1,7,255,255,254,
					240,0,0,0,0,0,0,0,

					0,0,0,0,0,0,1,7,
					31,63,126,120,240,224,224,224,
					224,224,240,120,62,63,31,7,
					0,0,0,0,0,0,0,0
				},

	//7
	{
		0,0,0,0,0,0,28,28,
		28,28,28,28,28,28,28,28,
		28,28,28,28,156,252,252,252,
		60,0,0,0,0,0,0,0,

		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		192,224,248,254,63,15,3,0,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,0,0,0,
		0,0,0,0,192,240,252,255,
		63,15,3,0,0,0,0,0,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,0,0,0,
		192,240,252,127,63,15,3,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	},
	// 8

	{
		0,0,0,0,0,0,128,224,
		240,248,60,28,28,14,14,14,
		14,28,28,60,248,240,224,128,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,0,7,31,
		63,127,248,240,224,224,192,192,
		128,192,192,240,127,63,31,7,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,192,248,252,
		254,31,7,3,1,1,1,3,
		3,7,7,15,63,254,252,248,
		192,0,0,0,0,0,0,0,

		0,0,0,0,0,0,15,31,
		63,126,120,240,224,224,224,224,
		224,224,240,120,126,63,31,7,
		0,0,0,0,0,0,0,0
	},

	//9
	{
		0,0,0,0,0,0,192,224,
		240,248,60,28,28,30,30,30,
		30,28,60,248,248,240,192,0,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,62,255,255,
		255,192,0,0,0,0,0,0,
		0,0,0,0,255,255,255,254,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,0,1,3,
		7,15,15,30,30,28,28,28,
		28,14,14,134,255,255,255,63,
		0,0,0,0,0,0,0,0,

		0,0,0,0,0,0,0,0,
		240,240,224,224,224,224,240,112,
		120,120,62,31,15,7,1,0,
		0,0,0,0,0,0,0,0
	},

	{
0,0,0,1,3,255,255,128,  //символ км/ч
192,96,48,16,16,0,32,112,
240,240,32,48,48,240,224,32,
48,48,240,224,0,0,0,0,


128,128,128,128,136,143,143,137,
131,135,142,140,136,128,136,140,
143,143,136,128,136,143,143,136,
128,128,143,143,136,128,128,128,


0,0,0,0,0,0,0,0,
0,0,0,8,8,248,248,0,
128,128,128,128,0,0,0,0,
0,0,0,0,0,0,0,0,


0,0,0,0,0,0,0,0,
0,0,0,0,64,127,127,65,
1,1,127,127,64,0,0,0,
0,0,0,0,0,0,0,0
	},

	//Точка

	{
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,120,252,252,252,252,120
	}
};


//Маленькие цифры

// 17 символов размером 10х16, 2 страницы  памяти по 10 байта,2*10=20 ячеек для одного символа
const unsigned char znakogen_small[17][20] PROGMEM = {


	//0
	{
			240,252,14,6,6,6,14,252,
			240,0,

			31,127,224,192,192,192,224,127,
			31,0
	},
	//1
	{
			0,16,24,28,254,254,0,0,
			0,0,

			0,192,192,192,255,255,192,192,
			0,0
	},
	//2
	{
		   24,28,14,6,6,14,252,248,
		   0,0,

		   224,240,248,220,206,199,195,192,
		   192,0
	},
	//3
	{

		   24,28,6,134,134,134,206,124,
		   56,0,

		   96,224,192,193,193,193,227,127,
		   62,0
	},
	//4
	{
		   128,192,96,48,24,12,254,254,
		   0,0,

		   7,6,6,6,6,6,255,255,
		   6,0
	},
	//5
	{
		  0,254,254,198,198,198,198,134,
		  6,0,

		  0,97,193,192,192,192,225,127,
		  31,0
	},
	//6
	{
		  224,248,188,206,198,198,198,134,
		  0,0,

		  15,63,112,224,192,192,224,127,
		  63,0
	},
	//7
	{
		  14,14,6,6,6,198,254,126,
		  30,0,

		  0,192,240,124,31,7,1,0,
		  0,0
	},
	//8
   {
		 56,252,198,134,134,134,198,252,
		 56,0,

		 60,126,195,193,193,193,195,126,
		 60,0
   },
	//9
	{
		240,252,12,6,6,6,12,252,
		240,0,

		1,67,195,198,198,230,114,63,
		15,0
	},
	//rpm
	{
		0,0,222,74,74,74,148,0,
		0,0,

		0,0,115,9,113,9,112,0,
		0,0
	},
	//Volt
	{
		66,164,168,168,164,66,
		0,0,0,0,

		46,40,232,40,40,
		0,0,0,0,0
	},
	//градус цельсия
	{
		12,146,210,108,32,32,32,32,
		64,0,

		0,63,127,224,192,192,192,192,
		96,0

	},
	//km
	{
	   0,0,252,96,144,8,4,0,
	   0,0,

	   0,240,11,8,240,9,10,240,
	   0,0
	},

	//знак минус -
	{
		0,192,192,192,192,192,192,192,
		192,0,

		0,0,0,0,0,0,0,0,
		0,0
	}

};

//Два символа 6х16 		   
const unsigned char two_znak[2][12] PROGMEM = {

	//Cимвол ОДО
	{
	204,82,82,82,82,140,
	51,74,74,74,74,49
	},
	//Символ градуса
	{
	12,18,18,12,0,0,
	0,0,0,0,0,0
	}
};

enum i2c_read_mode_t
{
	I2C_START,
	I2C_DATA,
	I2C_DATA_ACK,
	I2C_STOP
};

unsigned char i2c_transmit(unsigned char type)
{
	unsigned char w;

	switch (type)
	{
	default:
	case I2C_START: // Send Start Condition
		TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
		break;
	case I2C_DATA: // Send Data with No-Acknowledge
		TWCR = (1 << TWINT) | (1 << TWEN);
		break;
	case I2C_DATA_ACK: // Send Data with Acknowledge
		TWCR = (1 << TWEA) | (1 << TWINT) | (1 << TWEN);
		break;
	case I2C_STOP: // Send Stop Condition
		TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
		return 0;
	}

	// Wait for TWINT flag set on Register TWCR
	while (!(TWCR & (1 << TWINT)));

	// Return TWI Status Register, mask the prescaller bits (TWPS1,TWPS0)
	return (TWSR & 0xF8);
}

void i2c_start(unsigned char addr)
{
	unsigned char n = 0;
	unsigned char twi_status;
	//char r_val = -1;
	unsigned char MAX_TRIES;
	MAX_TRIES = 3;

i2c_retry:
	if (n++ >= MAX_TRIES)
	{
		return;
	}

	// Transmit Start Condition
	twi_status = i2c_transmit(I2C_START);

	// Check the TWI Status
	if (twi_status == TW_MT_ARB_LOST)
		goto i2c_retry;
	if ((twi_status != TW_START) && (twi_status != TW_REP_START))
		goto i2c_quit;

	// Send slave address (SLA_W)
	TWDR = addr; // (dev_id & 0xF0) | (dev_addr & 0x07) | rw_type;

	// Transmit I2C Data
	twi_status = i2c_transmit(I2C_DATA);

	// Check the TWSR status
	if ((twi_status == TW_MT_SLA_NACK) || (twi_status == TW_MT_ARB_LOST))
		goto i2c_retry;
	if (twi_status != TW_MT_SLA_ACK)
		goto i2c_quit;

i2c_quit:
	return; //
}

void i2c_stop(void)
{
	i2c_transmit(I2C_STOP);
}

/* char */
void i2c_write(unsigned char data)
{
	unsigned char twi_status;
	//char r_val = -1;

	// Send the Data to I2C Bus
	TWDR = data;

	// Transmit I2C Data
	twi_status = i2c_transmit(I2C_DATA);

	// Check the TWSR status
	if (twi_status != TW_MT_DATA_ACK) goto i2c_quit;

	//r_val=0;

i2c_quit:
	return;
}


//tip==0 очистка,
//tip==1 черный,
//tip==2 шахматы.
void clear_LCD(unsigned  char tip)
{
	unsigned short a;

	i2c_start(0x70); //отсылаем адрес устройства,команда,запись
	i2c_write(0b10110000); 	//  Установить адрес страницы 0	0 1	0 1	1 #	# #	# Set PA[3:0]  страница 0

	i2c_write(0b00000000); 	// Установить адрес столбца LSB  000000####	Set CA [3:0] колонка 0
	i2c_write(0b00010000); 	//Установить адрес столбца MSB   000001####	Set CA [3:0] колонка 0

	i2c_stop();

	i2c_start(0x72);   //(0x70|0x02); отсылаем адрес устройства,данные,запись

	//выбор типа очистки
	if (tip == 0)
	{
		for (a = 0;a < 1056;a++)
			i2c_write(0x00);
	}
	else {
		if (tip == 1) {
			for (a = 0;a < 1056;a++)
			{
				if (a != 0) { i2c_start(0x72); };
				i2c_write(0xFF);
				i2c_stop();
				_delay_ms(10);
			}
		}
		else {
			for (a = 0;a < 528;a++)
			{
				i2c_write(0xAA);
				i2c_write(0x55);
			}
		}
	}

	i2c_stop();
}

//Функция установки страницы памяти(0-8) дисплея и столбцов памяти 0-132
void set_page(unsigned char page, unsigned char column)
{
	i2c_start(0x70); //отсылаем адрес устройства,команда,запись
	i2c_write(page | 0b10110000); 	//  Установить адрес страницы  1011 #	# #	# Set PA[3:0]  страница 0

	i2c_write(column & 0b00001111); 	// Установить адрес столбца LSB  000000####	Set CA [3:0] колонка 0
	column = column >> 4;
	i2c_write(column | 0b00010000); 	//Установить адрес столбца MSB   000001####	Set CA [7:4] колонка 0
	i2c_stop();
}

//Основная функция которая выводит все на экран.
// 0(first_column)-номер начального столбца с которого выводится изображение    
// 1(x_size)-ширина разряда в пикселях, или размер поля для символа по x координате
// 2 (nomber_razrad) -cколько разрядов будем выводить на экран
// 3 (first_page) -начальная страница памяти для вывода изображения
//4 (end_page)- конечная страница памяти для вывода изображения
//5 (data_array[]) -массив данных, содержащих номер в массиве знакогенератора, для вывода на экран
// работает только для маленьких символов 10х16, и содержащих не более 2х запятых в строке.
//6 (where_point) после какого разряда поставим запятую? если стоит цифра больше самих разрадов, > nomber_razrad то запятых не будет
//7 (where_point_one) вторая запятая. 
//8 (point_big_on) если point_big_on=1 значит в больших разрядах будет светится точка,если point_big_on=0 точки нет.
void send_pixel(unsigned char first_column, unsigned char x_size, unsigned char nomber_razrad, unsigned char first_page, unsigned char end_page, unsigned char data_array[],
	unsigned char where_point, unsigned char where_point_one, unsigned char point_big_on)
{
	unsigned char i, page, razrad, point;
	set_page(first_page, first_column); // Устанавливаем начальную страницу памяти с которой будем выводить изображение.

	for (page = first_page;page < end_page + 1;page++)  //Перелистываем страницы SDRAM дисплея
	{
		set_page(page, first_column); //Установили страницу памяти дисплея
		i2c_start(0x72);   //(0x70|0x02); отсылаем адрес устройства,данные,запись

		for (razrad = 0;razrad < nomber_razrad;razrad++) // Меняем разряд
		{
			for (i = 0;i < x_size;i++)  //Заполняем  символами сответствующий разряд
			{
				switch (x_size)
				{

					// Выводим маленькие цифры
				case 10:
				{
					if (data_array[razrad] != 20) //Если не пришел код гашения разряда
					{
						i2c_write(pgm_read_byte(&(znakogen_small[data_array[razrad]][i + (page - first_page) * x_size])));
					}
					else
					{
						i2c_write(0x00); // "Прозрачный" пробел в видет вертикальной полосы в 1 пиксель.
					};
				};
				break;

				case 32: //Выводим большие цифры					
				{

					if ((point_big_on == 1) & (page == 3) & (razrad == 1))  // Если точка включена
					{
						i2c_write((pgm_read_byte(&(znakogen[data_array[razrad]][(i + (page - first_page) * x_size)]))) +
							(pgm_read_byte(&(znakogen[11][i]))));
					}
					else
					{

						i2c_write(pgm_read_byte(&(znakogen[data_array[razrad]][i + (page - first_page) * x_size])));
					};
				};
				break;

				case 6:
				{
					i2c_write(pgm_read_byte(&(two_znak[data_array[razrad]][i + (page - first_page) * x_size])));

				};
				break;
				default:; break;
				};
			}

			//зажигаем "точку"
			if (((where_point == razrad) | (where_point_one == razrad)))
			{
				//делаем точку в 2 пикселя
				if (page == end_page)
				{

					i2c_write(96);
					i2c_write(224);
					i2c_write(0x00);
				}
				else
				{
					i2c_write(0x00);
					i2c_write(0x00);
					i2c_write(0x00);

				};
			};
		}
	}

	i2c_stop();
}

//Инициализация дисплея
void init_display(void)
{
	DDRD = 0b00000010;
	PORTD = 0b0000010; 	//Выводим дисплей  из состояния reset

	// настройка интерфейса I2C в режиме мастер
	//TWBR = (F_CPU / 100000UL - 16) / 2;
	i2c_PORT |= 1 << i2c_SCL | 1 << i2c_SDA; // Включим подтяжку на ноги, вдруг юзер на резисторы пожмотился
	i2c_DDR &= ~(1 << i2c_SCL | 1 << i2c_SDA);

	// Настроим битрейт
	//SCL frequency = CPU Clock frequency/ 16 + 2(TWBR) * (PrescalerValue)
	//400кгц=8000/20 ;20-16+2=2;
	//TWBR = (F_CPU / 100000UL - 16) / 2;

	TWBR = 2;//400кгц частота шины; //2 =400 //100
	TWSR = 0x00; //нет деления частоты кварца

	_delay_ms(300);

	i2c_start(0x70); //отсылаем адрес устройства,команда,запись
	i2c_write(0xe2);		// system reset
	i2c_write(0b00100100);   //001001##  //Установить Temp.Установить температурную компенсацию

	i2c_write(0b11000110);  // настройка типа разветки свеху в низ, и слево на право 154   //11000### // Установить LCD Mapping
	// Set LCD Mapping Control - включаем отзеркаливание RDX0154

	i2c_write(0b10100000); // 80 кадров в сек// 1010000# // Установить Frame Rate
	i2c_write(0b11101011); 	// BIAS 9  //111010##  Установить LCD Bias Ratio

	i2c_write(0b10000001);  // настройка Vbias
	i2c_write(0x80);  //Vbias=200

	i2c_write(0b10001001);  // Set RAM Address Control
	i2c_write(0b10101111); //Включить дисплей
	i2c_stop();
	clear_LCD(0);
}
